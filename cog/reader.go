package cog

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"image"
	"io"

	"github.com/jh-sz/cog/lzw"
)

// TODO: revisit error types
// A FormatError reports that the input is not a valid tiff image.
type FormatError string

//
func (e FormatError) Error() string {
	return "tiff: invalid format: " + string(e)
}

// An UnsupportedError reports that the input uses a valid but
// unimplemented feature.
type UnsupportedError string

func (e UnsupportedError) Error() string {
	return "tiff: unsupported feature: " + string(e)
}

type tiff struct {
	byteOrder binary.ByteOrder
	ifd       *IFD
}

type Metadata struct {
	Compression               uint16
	PlanarConfig              uint16
	Predictor                 uint16
	BitsPerSample             uint16
	PhotometricInterpretation uint16
	// TODO: not supporting extraSamples tag at the moment
	// extra samples are additional pixel value
	// specified by type from PhotometricInterpretation
	// e.g. extra sample for RGBA should has 1 value
	// and can be Associated alpha data / Unassociated alpha data
	// see spec p31 for details: https://www.awaresystems.be/imaging/tiff/specification/TIFF6.pdf
	// the value for extra samples should be an array of values
	// looks like the tiff generated by ai contains only 1 value
	//ExtraSamples              uint16
	SamplesPerPixel uint16

	ImageWidth  uint32 // TODO: short max 65536 pixels width
	ImageLength uint32 // TODO: short max 65536 pixels width

	TileOffSet    []uint32
	TileByteCount []uint32
	TileWidth     uint16
	TileLength    uint16

	// TODO:
	//Projection      string
	//ModelTiePoint   [6]float64
	//ModelPixelScale [3]float64
}

type Reader struct {
	r io.ReaderAt

	Metadata *Metadata

	tiff *tiff
}

// NewReader decodes the geotiff image, only the first ifd is taken into account
// it ignores the remaining IFDs
func NewReader(r io.Reader) (*Reader, error) {
	reader := &Reader{
		r: newReaderAt(r),
	}

	p := make([]byte, 8)
	if _, err := reader.r.ReadAt(p, 0); err != nil {
		return nil, err
	}

	reader.tiff = &tiff{}
	// extract header bytes
	// to determine byte order
	switch string(p[0:4]) {
	case leHeader:
		reader.tiff.byteOrder = binary.LittleEndian
	case beHeader:
		reader.tiff.byteOrder = binary.BigEndian
	default:
		return nil, FormatError("malformed header")
	}

	// first ifd offset
	ifdOffset := reader.tiff.byteOrder.Uint32(p[4:8])

	if err := reader.decodeIFD(int64(ifdOffset)); err != nil {
		return nil, err
	}
	if _, has := reader.tiff.ifd.GetTag(tTileWidth); !has {
		return nil, fmt.Errorf("only support cloud optimized geotiff")
	}

	var err error
	reader.Metadata, err = decodeMetadata(reader.tiff.byteOrder, reader.tiff.ifd)
	if err != nil {
		return nil, err
	}

	if reader.Metadata.BitsPerSample != 8 {
		return nil, fmt.Errorf("only support 8 bit format images, got %d", reader.Metadata.BitsPerSample)
	}

	return reader, nil
}

func (r *Reader) decodeIFD(ifdOffset int64) error {
	p := make([]byte, numOfEntriesByteLen)
	if _, err := r.r.ReadAt(p, ifdOffset); err != nil {
		return err
	}
	numEntries := int(r.tiff.byteOrder.Uint16(p))

	// read all entries of ifd
	enRaw := make([]byte, ifdEntryLen*numEntries)
	if _, err := r.r.ReadAt(enRaw, ifdOffset+numOfEntriesByteLen); err != nil {
		return err
	}

	var prevTag uint16
	ifd := &IFD{
		entriesMap: make(map[uint16]*entry),
	}

	for i := 0; i < len(enRaw); i += ifdEntryLen {
		en, err := r.parseEntry(enRaw[i : i+ifdEntryLen])
		if err != nil {
			return err
		}
		if en.TagID <= prevTag {
			return FormatError("tags are not sorted in ascending order")
		}
		prevTag = en.TagID

		ifd.entriesMap[en.TagID] = en
	}

	p = make([]byte, ifdNextValueLen)
	if _, err := r.r.ReadAt(p, ifdOffset+numOfEntriesByteLen+int64(ifdEntryLen*numEntries)); err != nil {
		return err
	}
	ifd.NextOffset = r.tiff.byteOrder.Uint32(p)
	r.tiff.ifd = ifd

	return nil
}

func (r *Reader) parseEntry(ent []byte) (*entry, error) {
	e := &entry{}
	e.TagID = r.tiff.byteOrder.Uint16(ent[:2])
	e.TypeID = r.tiff.byteOrder.Uint16(ent[2:4])
	e.Count = r.tiff.byteOrder.Uint32(ent[4:8])

	dt, has := dataLengthMap[e.TypeID]
	if !has {
		return nil, UnsupportedError(fmt.Sprintf("data type: %d", e.TypeID))
	}
	valSize := int(e.Count) * dt
	var valueOffset [entryValueLen]byte
	if err := binary.Read(bytes.NewReader(ent[8:]), r.tiff.byteOrder, &valueOffset); err != nil {
		return nil, err
	}

	if valSize > entryValueLen {
		e.value = make([]byte, valSize)
		if _, err := r.r.ReadAt(e.value, int64(r.tiff.byteOrder.Uint32(valueOffset[:]))); err != nil {
			return nil, err
		}
	} else {
		e.value = valueOffset[:]
	}

	return e, nil
}

func decodeMetadata(byteOrder binary.ByteOrder, ifd *IFD) (*Metadata, error) {
	imgWidthTag, has := ifd.GetTag(tImageWidth)
	if !has {
		return nil, errors.New("image width tag not found")
	}
	imgLenTag, has := ifd.GetTag(tImageLength)
	if !has {
		return nil, errors.New("image length tag not found")
	}
	piTag, has := ifd.GetTag(tPhotometricInterpretation)
	if !has {
		return nil, errors.New("photometric interpretation tag not found")
	}
	bsTag, has := ifd.GetTag(tBitsPerSample)
	if !has {
		return nil, errors.New("bits per sample tag not found")
	}
	offsetTag, has := ifd.GetTag(tTileOffsets)
	if !has {
		return nil, errors.New("tag tiles offset not found")
	}
	enByteCount, has := ifd.GetTag(tTileByteCounts)
	if !has {
		return nil, errors.New("tag tiles byte counts not found")
	}
	if offsetTag.Count != enByteCount.Count {
		return nil, fmt.Errorf("invalid cog format TileOffsets count (%d) not the same as TilesByteCount count (%d)", offsetTag.Count, enByteCount.Count)
	}
	sppTag, has := ifd.GetTag(tSamplesPerPixel)
	if !has {
		return nil, errors.New("SamplesPerPixel tag is misssing")
	}
	tileWidthTag, has := ifd.GetTag(tTileWidth)
	if !has {
		return nil, errors.New("missing TileWidth tag")
	}
	tileLenTag, has := ifd.GetTag(tTileLength)
	if !has {
		return nil, errors.New("missing TileLength tag")
	}
	predictTag, has := ifd.GetTag(tPredictor)
	if !has {
		return nil, errors.New("predictor tag not found")
	}
	pcTag, has := ifd.GetTag(tPlanarConfiguration)
	if !has {
		return nil, errors.New("planar configuration tag not found")
	}
	comprTag, has := ifd.GetTag(tCompression)
	if !has {
		return nil, errors.New("compression tag not found")
	}

	piVal := byteOrder.Uint16(piTag.value)
	bitsPerSample := byteOrder.Uint16(bsTag.value)
	tilesOffsets := make([]uint32, offsetTag.Count)
	if err := binary.Read(bytes.NewBuffer(offsetTag.value), byteOrder, &tilesOffsets); err != nil {
		return nil, err
	}
	tilesByteCounts := make([]uint32, enByteCount.Count)
	if err := binary.Read(bytes.NewBuffer(enByteCount.value), byteOrder, &tilesByteCounts); err != nil {
		return nil, err
	}
	spp := byteOrder.Uint16(sppTag.value)
	tileWidth := byteOrder.Uint16(tileWidthTag.value)
	tileLen := byteOrder.Uint16(tileLenTag.value)
	predictor := byteOrder.Uint16(predictTag.value)
	planarConfig := byteOrder.Uint16(pcTag.value)
	compressionType := byteOrder.Uint16(comprTag.value)
	imgWidth := byteOrder.Uint32(imgWidthTag.value)
	imgLen := byteOrder.Uint32(imgLenTag.value)

	return &Metadata{
		Compression:               compressionType,
		PlanarConfig:              planarConfig,
		Predictor:                 predictor,
		BitsPerSample:             bitsPerSample,
		PhotometricInterpretation: piVal,
		ImageWidth:                imgWidth,
		ImageLength:               imgLen,
		TileOffSet:                tilesOffsets,
		TileByteCount:             tilesByteCounts,
		TileLength:                tileLen,
		TileWidth:                 tileWidth,
		SamplesPerPixel:           spp,
	}, nil
}

// Read returns given tiles as a slice of images
// these images can be containing 1 or more channels depending on the
// geotiff file
// only BlackIsZero is supported at the moment, i.e. gray images
func (r *Reader) Read(tileIndexes ...int) ([]image.Image, error) {
	if r.Metadata.BitsPerSample != 8 {
		return nil, fmt.Errorf("only support 8 bit format images, got %d", r.Metadata.BitsPerSample)
	}

	// TODO: handle other image types
	// return image based on type e.g. gray
	switch r.Metadata.PhotometricInterpretation {
	case pBlackIsZero:
		return r.decodeGrays(tileIndexes)
	default:
		return nil, fmt.Errorf("photometric interpretation value %d not supported", r.Metadata.PhotometricInterpretation)
	}
}

func (r *Reader) decodeGrays(tileIndexes []int) ([]image.Image, error) {
	out := make([]image.Image, 0, 1)
	for _, idx := range tileIndexes {
		// make sure input is within range
		if idx > len(r.Metadata.TileOffSet) {
			return nil, fmt.Errorf("input value %d greater than number of tiles found in tiff %d", idx, len(r.Metadata.TileOffSet))
		}
		off := r.Metadata.TileOffSet[idx]
		n := r.Metadata.TileByteCount[idx]

		grays, err := r.bandsAsGrays(off, n)
		if err != nil {
			return nil, err
		}
		for _, img := range grays {
			out = append(out, img)
		}
	}
	return out, nil
}

// bandsAsGrays returns all bands as gray images of a single tile in tiff
func (r *Reader) bandsAsGrays(off, n uint32) ([]*image.Gray, error) {
	rawTile, err := r.getTileRaw(off, n)
	if err != nil {
		return nil, err
	}

	outImages := make([]*image.Gray, r.Metadata.SamplesPerPixel)
	sameplesPerPixel := int(r.Metadata.SamplesPerPixel)
	tileLength := int(r.Metadata.TileLength)
	tileWidth := int(r.Metadata.TileWidth)

	if r.Metadata.PlanarConfig == pcChunky {
		res := make([][]uint8, sameplesPerPixel)
		for i := range res {
			res[i] = make([]uint8, tileLength*tileWidth)
		}

		// spp bands per pixel
		// going through each pixel and splitting out each band
		for i := 0; i < tileLength*tileWidth; i++ {
			for s := 0; s < sameplesPerPixel; s++ {
				res[s][i] = rawTile[i*sameplesPerPixel+s]
			}
		}
		switch r.Metadata.Predictor {
		case prHorizontal:
			for _, tile := range res {
				for y := 0; y < tileLength; y++ {
					for x := 0; x < tileWidth; x++ {
						pos := y*tileLength + x
						tile[pos+1] += tile[pos]
					}
				}
			}
		}
		for i, t := range res {
			gray := image.NewGray(image.Rect(0, 0, tileWidth, tileLength))
			gray.Pix = t
			outImages[i] = gray
		}
	} else {
		return nil, fmt.Errorf("only support planar config chunky format got %d", r.Metadata.PlanarConfig)
	}

	return outImages, nil
}

func (r *Reader) getTileRaw(off, n uint32) ([]byte, error) {
	byts := make([]byte, n)
	if _, err := r.r.ReadAt(byts, int64(off)); err != nil {
		return nil, err
	}

	switch r.Metadata.Compression {
	case cNone, 0:
		return byts, nil
	case cLZW:
		var buff bytes.Buffer
		lzwReader := lzw.NewReader(bytes.NewReader(byts), lzw.MSB, 8)
		defer lzwReader.Close()
		if _, err := io.Copy(&buff, lzwReader); err != nil {
			return nil, err
		}

		return buff.Bytes(), nil
	}

	return nil, fmt.Errorf("compression type (%d) unsupported", r.Metadata.Compression)
}
